import path from 'path';

import Handlebars from 'handlebars';
import { JSONSchema7 as JSONSchema } from 'json-schema';
import { capitalize } from 'lodash';

import { OperationExecutionEngine, OperationType } from '@wundergraph/protobuf';
import { CodeGenerationConfig, GraphQLOperation, Template, TemplateOutputFile } from '@wundergraph/sdk';

import { hasInput } from '@wundergraph/sdk/internal/codegen';
import {
	operationInputTypename,
	operationResponseTypename,
} from '@wundergraph/sdk/dist/codegen/templates/typescript/helpers';

const clientPackageName = 'wundergraph-rust-client';
const clientPackageNamespace = clientPackageName.replace(/-/g, '_');

export interface RustClientTemplateConfig {
	packageName: string;
	packageVersion?: string;
}

const defaultTemplateConfig: RustClientTemplateConfig = {
	packageName: 'app',
};

const fileHeader = (comment: string = '//') => `${comment} Code generated by wunderctl. DO NOT EDIT.\n\n`;

const capitalizeFirstChar = (name: string) => capitalize(name.substring(0, 1)) + name.substring(1);

const toCamelCase = (s: string) => {
	let out = '';
	for (const component of s.split('_')) {
		out += capitalizeFirstChar(component);
	}
	return out;
};

const toSnakeCase = (s: string) => {
	// TODO: This messes up GraphQL to graph_q_l
	return s
		.split(/(?=[A-Z])/)
		.map((s) => s.toLowerCase())
		.join('_');
};

const clientRsTemplate = `	
pub struct Client {
	pub client: ${clientPackageNamespace}::Client,
}

pub type Options = ${clientPackageNamespace}::ClientOptions;

impl Client {
	pub fn new(url: Option<${clientPackageNamespace}::Url>) -> Self {
		Client::new_with_options(Options{
			url: url,
		})
	}

	pub fn new_with_options(options: Options) -> Self {
		Self {
			client: ${clientPackageNamespace}::Client::new(options),
		}
	}
}
`;

class ClientRs implements Template {
	constructor(private config: RustClientTemplateConfig) {}

	async generate(_: CodeGenerationConfig): Promise<TemplateOutputFile[]> {
		return Promise.resolve([
			{
				path: path.join('src', 'client.rs'),
				content: clientRsTemplate,
				header: fileHeader(),
			},
		]);
	}
}

const libRsTemplate = `

type Result<T> = std::result::Result<T, ${clientPackageNamespace}::Error>;

pub use ${clientPackageNamespace}::{Error, Url};

mod client;
pub use client::{Client, Options};
mod inputs;
pub use inputs::*;
mod responses;
pub use responses::*;
mod queries;
mod mutations;
`;

class LibRs implements Template {
	constructor(private config: RustClientTemplateConfig) {}

	async generate(_: CodeGenerationConfig): Promise<TemplateOutputFile[]> {
		return Promise.resolve([
			{
				path: path.join('src', 'lib.rs'),
				content: libRsTemplate,
				header: fileHeader(),
			},
		]);
	}
}

const cargoTomlTemplate = `
[package]
name = "{{packageName}}"
version = "{{packageVersion}}"
edition = "2021"

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[features]
tls = ["${clientPackageName}/tls"]

[dependencies]
serde = { version = "1.0.188", features = [ "serde_derive" ] }
serde_json = "1.0.105"
${clientPackageName} = { git = "https://github.com/wundergraph/rust-client.git" }
`;

class CargoToml implements Template {
	constructor(private config: RustClientTemplateConfig) {}

	async generate(_: CodeGenerationConfig): Promise<TemplateOutputFile[]> {
		const tmpl = Handlebars.compile(cargoTomlTemplate);
		const content = tmpl({
			packageName: this.config.packageName,
			packageVersion: this.config.packageVersion ?? '0.0.1',
		});
		return Promise.resolve([
			{
				path: path.join('Cargo.toml'),
				content,
				header: fileHeader('#'),
			},
		]);
	}
}

const typeAnnotations = `#[derive(Debug, serde::Serialize, serde::Deserialize)]\n`;

class rustEncoder {
	private readonly types: Map<string, string>;
	private output: string = '';

	constructor(private rootSchema: JSONSchema, private rootTypeName: string, definedTypes?: Map<string, string>) {
		this.types = definedTypes ?? new Map();
	}

	encode() {
		let encoded = this.encodeType(this.rootSchema, this.rootTypeName);
		if (this.output == '') {
			// Output is not a struct, handle it here
			return `pub type ${this.encodeTypeName(this.rootTypeName)} = ${encoded};\n`;
		}
		return this.output;
	}

	definedTypes() {
		return new Map(this.types);
	}

	private encodeFieldName(name: string) {
		const fieldName = toSnakeCase(name);
		// From https://doc.rust-lang.org/reference/keywords.html
		const reserved = [
			// strict keywords
			'as',
			'break',
			'const',
			'continue',
			'crate',
			'else',
			'enum',
			'extern',
			'false',
			'fn',
			'for',
			'if',
			'impl',
			'in',
			'let',
			'loop',
			'match',
			'mod',
			'move',
			'mut',
			'pub',
			'ref',
			'return',
			'self',
			'Self',
			'static',
			'struct',
			'super',
			'trait',
			'true',
			'type',
			'unsafe',
			'use',
			'where',
			'while',
			// added in 2018 edition
			'async',
			'await',
			'dyn',
			// reserved
			'abstract',
			'become',
			'box',
			'do',
			'final',
			'macro',
			'override',
			'priv',
			'typeof',
			'unsized',
			'virtual',
			'yield',
			// added to reserved in 2018 edition
			'try',
			// weak keywords
			'macro_rules',
			'union',
			"'static",
		];
		if (reserved.includes(fieldName)) {
			return `_${fieldName}`;
		}
		return fieldName;
	}

	private encodeTypeName(name: string) {
		return toCamelCase(name);
	}

	private outputTypeDefinition(typeName: string, typeDefinition: string) {
		const prevDefinition = this.types.get(typeName);
		if (prevDefinition) {
			if (prevDefinition !== typeDefinition) {
				throw new Error(`can't redefine type ${typeName} from ${prevDefinition} to ${typeDefinition}`);
			}
			// Nothing to add to the output
			return;
		}
		this.types.set(typeName, typeDefinition);
		this.output += typeDefinition;
	}

	private encodeType(typeSchema: JSONSchema, typeName?: string): string {
		if (typeSchema.$ref) {
			if (!typeSchema.$ref.startsWith('#/')) {
				throw new Error(`can't resolve ref ${typeSchema.$ref}`);
			}
			const refComponents = typeSchema.$ref.substring(2).split('/');
			let current = this.rootSchema;
			for (const component of refComponents) {
				const next = (current as any)[component];
				if (typeof next === 'undefined') {
					throw new Error(`can't resolve ${component} while looking up $ref ${typeSchema.$ref}`);
				}
				current = next;
			}
			return this.encodeType(current as JSONSchema, refComponents[refComponents.length - 1]);
		}
		let type = typeSchema.type;
		let optional = false;
		if (Array.isArray(type)) {
			if (type.includes('null')) {
				optional = true;
				type = type.filter((x) => x !== 'null');
			}
			if (type.length > 1) {
				throw new Error(`can't encode type ${type}`);
			}
			type = type[0];
		} else if (!type) {
			if (typeof typeSchema !== 'object' || Object.keys(typeSchema).length !== 0) {
				throw new Error(`invalid type schema ${typeSchema}`);
			}
		}
		const ifOptional = (typeName: string) => {
			if (optional) {
				return `Option<${typeName}>`;
			}
			return typeName;
		};
		switch (type) {
			case 'boolean':
				return ifOptional('bool');
			case 'integer':
				return ifOptional('i64');
			case 'number':
				return ifOptional('f64');
			case 'string':
				return ifOptional('String');
			case 'array':
				const itemSchema = typeSchema.items;
				if (!itemSchema || typeof itemSchema === 'boolean') {
					throw new Error(`can't encode array with item schema ${itemSchema}`);
				}
				if (Array.isArray(itemSchema)) {
					throw new Error(`can't encode array with multiple item schemas ${itemSchema}`);
				}
				const itemType = this.encodeType(itemSchema, `${typeName}_item`);
				return ifOptional(`Vec<${itemType}>`);
			case 'object':
				if (!typeName) {
					throw new Error(`no type name for ${JSON.stringify(typeSchema)}`);
				}
				const structTypeName = this.encodeTypeName(typeName);
				let def = typeAnnotations;
				def += `pub struct ${structTypeName} {\n`;
				const typeProperties = typeSchema.properties ?? {};
				for (const propName of Object.keys(typeProperties)) {
					const propSchema = typeProperties[propName];
					if (typeof propSchema === 'boolean') {
						throw new Error(`can't encode ${propName} in ${typeName}`);
					}
					// Provide a fallback typeName for anonymous embedded objects
					const propTypeName = `${typeName}_${propName}`;
					const propType = this.encodeType(propSchema, propTypeName);
					if (!propType) {
						throw new Error(`property ${propName} with schema ${JSON.stringify(propSchema)} returned an empty type`);
					}
					if (optional) {
						def += `\t#[serde(skip_serializing_if = "Option::is_none")]\n`;
					}
					def += `\t#[serde(rename(serialize = "${propName}", deserialize = "${propName}"))]\n`;
					def += `\tpub ${this.encodeFieldName(propName)}: ${propType},\n`;
				}
				def += `}\n\n`;
				this.outputTypeDefinition(structTypeName, def);
				return ifOptional(structTypeName);
			case undefined:
				return ifOptional('std::collections::HashMap<String, serde_json::Value>');
			default:
				throw new Error(`can't encode type ${type}`);
		}
	}
}

class Inputs implements Template {
	constructor(private config: RustClientTemplateConfig) {}

	async generate(generationConfig: CodeGenerationConfig): Promise<TemplateOutputFile[]> {
		let definedTypes: Map<string, string> | undefined;
		const contents: string[] = [];
		for (const op of generationConfig.config.application.Operations.filter(hasInput)) {
			const encoder = new rustEncoder(op.VariablesSchema, operationInputTypename(op), definedTypes);
			const opContent = encoder.encode();
			definedTypes = encoder.definedTypes();
			contents.push(opContent);
		}
		const content = contents.join('\n\n');
		return Promise.resolve([
			{
				path: path.join('src', 'inputs.rs'),
				content,
				header: fileHeader(),
			},
		]);
	}
}

class Responses implements Template {
	constructor(private config: RustClientTemplateConfig) {}

	async generate(generationConfig: CodeGenerationConfig): Promise<TemplateOutputFile[]> {
		let definedTypes: Map<string, string> | undefined;
		const contents: string[] = [];
		for (const op of generationConfig.config.application.Operations) {
			// GraphQL operations have root "data" and "errors" fields. We handle this
			// separately so we don't need a wrapper struct.
			// TypeScript operations contain the data at the root level hence we take
			// op.ResponseSchema directly for those
			let responseSchema: JSONSchema;
			switch (op.ExecutionEngine) {
				case OperationExecutionEngine.ENGINE_GRAPHQL:
					responseSchema = op.ResponseSchema.properties?.['data'] as JSONSchema;
					break;
				case OperationExecutionEngine.ENGINE_NODEJS:
					responseSchema = op.ResponseSchema;
					break;
				default:
					throw new Error(`invalid execution operation execution engine ${op.ExecutionEngine}`);
			}
			if (typeof responseSchema === 'undefined') {
				throw new Error(`could to retrieve response schema for ${op.Name}`);
			}
			if (typeof responseSchema === 'boolean') {
				throw new Error(`can't encode response type for ${op.Name}`);
			}
			const encoder = new rustEncoder(responseSchema, operationResponseTypename(op), definedTypes);
			const opContent = encoder.encode();
			definedTypes = encoder.definedTypes();
			contents.push(opContent);
		}
		const content = contents.join('\n\n');
		return Promise.resolve([
			{
				path: path.join('src', 'responses.rs'),
				content,
				header: fileHeader(),
			},
		]);
	}
}

const queriesTemplate = `use crate::client::Client;
use crate::inputs::*;
use crate::responses::*;
use crate::Result;

#[derive(serde::Serialize)]
struct Empty {}

impl Client {
	{{#each queries}}
	{{#if allowNoSnakeCase}}
	#[allow(non_snake_case)]
	{{/if}}
	pub async fn {{name}}(&self{{#if hasInput}}, input: {{inputTypeName}}{{/if}}) -> Result<{{responseTypeName}}> {
		{{#if hasInput}}
		self.client.query("{{path}}", input).await
		{{else}}
		self.client.query("{{path}}", Empty{}).await
		{{/if}}
	}
	{{/each}}
}`;

const operationContext = (op: GraphQLOperation) => {
	return {
		name: toSnakeCase(op.Name),
		inputTypeName: toCamelCase(operationInputTypename(op)),
		responseTypeName: toCamelCase(operationResponseTypename(op)),
		allowNoSnakeCase: toSnakeCase(op.Name).includes('__'),
		path: op.PathName,
		hasInput: hasInput(op),
	};
};

class Queries implements Template {
	constructor(private config: RustClientTemplateConfig) {}

	async generate(generationConfig: CodeGenerationConfig): Promise<TemplateOutputFile[]> {
		const config = generationConfig.config;
		const tmpl = Handlebars.compile(queriesTemplate);
		const content = tmpl({
			queries: config.application.Operations.filter((op) => op.OperationType === OperationType.QUERY).map(
				operationContext
			),
		});
		return Promise.resolve([
			{
				path: path.join('src', 'queries.rs'),
				content,
				header: fileHeader(),
			},
		]);
	}
}

const mutationsTemplate = `use crate::client::Client;
use crate::inputs::*;
use crate::responses::*;
use crate::Result;

#[derive(serde::Serialize)]
struct Empty {}

impl Client {
	{{#each mutations}}
	pub async fn {{name}}(&self{{#if hasInput}}, input: {{inputTypeName}}{{/if}}) -> Result<{{responseTypeName}}> {
		{{#if hasInput}}
			self.client.mutate("{{path}}", input).await
		{{else}}
			self.client.mutate("{{path}}", Empty{}).await
		{{/if}}
	}
	{{/each}}
}`;

class Mutations implements Template {
	constructor(private config: RustClientTemplateConfig) {}

	async generate(generationConfig: CodeGenerationConfig): Promise<TemplateOutputFile[]> {
		const config = generationConfig.config;
		const tmpl = Handlebars.compile(mutationsTemplate);
		const content = tmpl({
			mutations: config.application.Operations.filter((op) => op.OperationType === OperationType.MUTATION).map(
				operationContext
			),
		});
		return Promise.resolve([
			{
				path: path.join('src', 'mutations.rs'),
				content,
				header: fileHeader(),
			},
		]);
	}
}

export const rustClient = (config: RustClientTemplateConfig = defaultTemplateConfig): Template[] => {
	return [
		new CargoToml(config),
		new LibRs(config),
		new ClientRs(config),
		new Inputs(config),
		new Responses(config),
		new Queries(config),
		new Mutations(config),
	];
};
