import { ResolvedWunderGraphConfig } from '../configure';
import path from 'path';
import * as fs from 'fs';

export interface TemplateOutputFile {
	path: string;
	content: string;
	header?: string;
}

export interface Template {
	generate: (config: ResolvedWunderGraphConfig) => Promise<TemplateOutputFile[]>;
	dependencies?: () => Template[];
}

export interface CodeGenConfig {
	basePath: string;
	wunderGraphConfig: ResolvedWunderGraphConfig;
	templates: Template[];
}

export interface CodeGenOutWriter {
	writeFileSync: (path: string, content: string) => void;
}

class FileSystem implements CodeGenOutWriter {
	writeFileSync(path: string, content: string): void {
		ensurePath(path);
		fs.writeFileSync(path, content);
	}
}

const ensurePath = (filePath: string) => {
	const dir = path.dirname(filePath);
	if (!fs.existsSync(dir)) {
		fs.mkdirSync(dir, { recursive: true });
	}
};

export const doNotEditHeader = '// Code generated by wunderctl. DO NOT EDIT.\n\n';

export const GenerateCode = async (config: CodeGenConfig, customOutWriter?: CodeGenOutWriter) => {
	config.templates
		.filter((tmpl) => tmpl !== undefined)
		.forEach((tmpl) => {
			if (!tmpl.dependencies) {
				return;
			}
			const deps = tmpl.dependencies();
			config.templates.push(...deps);
		});

	const dedupedTemplates: Template[] = [];

	config.templates
		.filter((tmpl) => tmpl !== undefined)
		.forEach((tmpl) => {
			const exists = dedupedTemplates.find((value) => value.constructor.name === tmpl.constructor.name) !== undefined;
			if (!exists) {
				dedupedTemplates.push(tmpl);
			}
		});

	const outWriter = customOutWriter || new FileSystem();
	const generators: Promise<TemplateOutputFile[]>[] = [];
	dedupedTemplates.forEach((template) => {
		generators.push(template.generate(config.wunderGraphConfig));
	});
	const resolved = await Promise.all(generators);
	const rawOutFiles: TemplateOutputFile[] = resolved.reduce((previousValue, currentValue) => [
		...previousValue,
		...currentValue,
	]);
	const outFiles = mergeTemplateOutput(rawOutFiles);
	outFiles.forEach((file) => {
		const content = `${file.header || ''}${file.content}`;
		const outPath = path.join(config.basePath, file.path);
		outWriter.writeFileSync(outPath, content);
		console.log(`${new Date().toLocaleTimeString()}: ${outPath} updated`);
	});
};

export const mergeTemplateOutput = (outFiles: TemplateOutputFile[]): TemplateOutputFile[] => {
	const merged: TemplateOutputFile[] = [];
	outFiles.forEach((file) => {
		const existing = merged.find((out) => out.path === file.path);
		if (existing) {
			existing.content += '\n\n' + file.content;
		} else {
			merged.push(file);
		}
	});
	merged.forEach((file) => {
		while (file.content.search('\n\n\n') !== -1) {
			file.content = file.content.replace('\n\n\n', '\n\n');
		}
	});
	return merged;
};
