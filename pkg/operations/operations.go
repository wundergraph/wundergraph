package operations

import (
	"errors"
	"io"
	"os"
	"path/filepath"
	"strings"
)

const DirectoryName = "operations"

func GetPaths(wunderGraphDir string) ([]string, error) {
	operationsDirectoryAbs := filepath.Join(wunderGraphDir, DirectoryName)
	var operationFilePaths []string
	err := filepath.Walk(operationsDirectoryAbs, func(path string, info os.FileInfo, err error) error {
		if info.IsDir() || strings.HasSuffix(info.Name(), ".d.ts") || !strings.HasSuffix(info.Name(), ".ts") {
			return nil
		}
		path, err = filepath.Rel(wunderGraphDir, path)
		if err != nil {
			return err
		}
		operationFilePaths = append(operationFilePaths, path)
		return nil
	})
	if err != nil {
		return nil, err
	}
	return operationFilePaths, nil
}

func Cleanup(wunderGraphDir string, paths []string) error {
	expected := make([]string, 0, len(paths)*2)
	for _, path := range paths {
		expected = append(expected,
			filepath.Join(wunderGraphDir, "generated", "bundle", strings.Replace(path, ".ts", ".js", 1)),
			filepath.Join(wunderGraphDir, "generated", "bundle", strings.Replace(path, ".ts", ".js.map", 1)),
		)
	}
	operationsBundlePath := filepath.Join(wunderGraphDir, "generated", "bundle", "operations")
	if _, err := os.Stat(operationsBundlePath); errors.Is(err, os.ErrNotExist) {
		return nil
	}
	err := filepath.Walk(operationsBundlePath, func(path string, info os.FileInfo, err error) error {
		if info == nil || info.IsDir() {
			return nil
		}
		if !contains(expected, path) {
			return os.Remove(path)
		}
		return nil
	})
	if err != nil {
		return err
	}
	return filepath.Walk(filepath.Join(wunderGraphDir, "generated", "bundle", "operations"), func(path string, info os.FileInfo, err error) error {
		if !info.IsDir() {
			return nil
		}
		// check if directory is empty
		empty, err := isDirEmpty(path)
		if err != nil {
			return err
		}
		if empty {
			return os.Remove(path)
		}
		return nil
	})
}

func isDirEmpty(name string) (bool, error) {
	f, err := os.Open(name)
	if err != nil {
		return false, err
	}
	defer f.Close()

	_, err = f.Readdirnames(1)
	if err == io.EOF {
		return true, nil
	}
	return false, err
}

func contains(paths []string, path string) bool {
	for _, p := range paths {
		if p == path {
			return true
		}
	}
	return false
}

func EnsureWunderGraphFactoryTS(wunderGraphDir string) error {
	path := filepath.Join(wunderGraphDir, "generated")
	err := os.MkdirAll(path, os.ModePerm)
	if err != nil {
		return err
	}
	path = filepath.Join(path, "wundergraph.factory.ts")
	return os.WriteFile(path, []byte(wunderGraphFactoryTSContent), os.ModePerm)
}

const (
	wunderGraphFactoryTSContent = `// Code generated by wunderctl. DO NOT EDIT.

import type { InternalClient } from "./wundergraph.internal.client";
import { InternalOperationsClient } from "./wundergraph.internal.operations.client";
import type { Role } from "./wundergraph.server";
import type { CustomClaims } from "./claims";
import { createOperationFactory } from "@wundergraph/sdk/operations";

export {z, AuthorizationError} from "@wundergraph/sdk/operations";
export const createOperation = createOperationFactory<InternalClient, Role, CustomClaims, InternalOperationsClient>();
`
)
